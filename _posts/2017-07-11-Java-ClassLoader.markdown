---
layout: post
title:      "Java类加载器"
subtitle:   "Java Class Loader"
date:       2017-07-11 12:00:00
author:     "Zhouxj"
header-img: "img/post-bg-classloader.jpg"
catalog: true
comments: true
tags:
    - java
    - jvm
    - 读书笔记
---

>  《深入理解Java虚拟机》 第七章

### 概述
类型的加载，连接和初始化过程都是在运行期间完成的。<br>
虚拟机把描述类的数据class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是类加载机制。

### 类加载的时机
加载，验证，准备，初始化和卸载这5个阶段是确定的。<br>
有5种情况必须对类进行初始化。，对一个类进行主动引用。

### 类加载过程
* 加载
虚拟机需要完成以下3件事情<br>
1）通过一个类的全限定名来获取定义此类的二进制字节流<br>
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>
3）在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口<br>

* 验证
目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>
1）文件格式验证<br>
2）元数据验证<br>
3）字节码验证<br>
4）符合引用验证<br>
将符合引用转化为直接引用，这个转化动作将在连接的第三阶段——解析阶段中发生

* 准备
正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配<br>
注意两点：<br>
1，类变量不包括实例变量，实例变量将在对象实例化时随着对象一起分配在java堆中<br>
2，初始值“通常情况”下是数据类型的零值。“特殊情况”：存在ConstantValue属性，例如public static final int value = 123;

* 解析
将常量池内的符合引用替换为直接引用的过程。<br>
对于同一个符合引用进行多次解析请求是很常见的事情，除了invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符合引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。
<br>
如果查找过程成功返回了引用，将会对这个类/字段/接口进行权限验证。

* 初始化
执行构造器<clinit>()方法的过程。<br>
<clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块(static{})中的语句合并产生的。<br>
子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。<br>
执行接口的<clinit>()方法不需要先执行父接口的<clinit>()。只有当父接口定义的变量使用时，父接口才会初始化。<br>
多线程环境中<clinit>()被正确地加锁，同步。

### 双亲委派模型
要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。