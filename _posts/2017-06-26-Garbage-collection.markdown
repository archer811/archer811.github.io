---
layout: post
title:      "读书笔记——垃圾收集器与内存分配策略"
subtitle:   "Garbage collection"
date:       2017-06-26 20:00:00
author:     "Zhouxj"
header-img: "img/post-bg-2015.jpg"
catalog: true
comments: true
tags:
    - java
    - jvm
    - 读书笔记
---

> 《深入理解Java虚拟机》 第三章

### 判断对象是否已死
1，引用计数算法（很难解决对象之间相互循环引用的问题）
2，可达性分析算法（主流实现）。

### 垃圾收集算法
* **1，标记-清除算法**
标记完成之后统一回收所有被标记的对象
缺点：标记和清除效率低；会产生大量不连续内存碎片。<br>
* **2，复制算法**
划分成相等两块，每次只使用其中一块，当这一块内存用完，就将还存在的对象复制到另一块上面，然后再已使用的内存空间一次清理掉。<br>
* **3，标记-整理算法**
标记，让存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br>
* **4，分代收集算法**
老年代因对象存活率高，没有额外空间对它进行担保，必须使用“标记-清理”或者“标记-整理”算法。<br>

### 垃圾收集器
<img src="//archer811.github.io/img/GC-1.png"  width="680" alt="GC"/>
所有收集器如上图



### 内存分配与回收策略
* **对象优先在Eden分配**
大多数情况下，对象在新生代Eden区分配。当Eden区没有足够空间进行分配，虚拟机发起一次MinorGC。
* **大对象直接进入老年代**

  最典型的大对象就是很长的字符串以及数组。

  -XX:PretenureSizeThreshold,大于这个设置值直接在老年代分配

  3145728，不能直接写3MB

* **长期存活的对象将进入老年代**

  如果对象在Eden出生并经过第一次MinorGC后仍然存活，被Survivor容纳，被移动到Survivor空间，对象年龄设为1。每”熬“过一次MinorGC年龄就加1。大于等于-XX:MaxTenuringThreshold进入老年代